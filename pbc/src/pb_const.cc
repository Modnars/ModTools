/*
 * @Author: modnarshen
 * @Date: 2022/05/18 17:41:09
 * @LastEditors: modnarshen
 * @Description: 工具主体功能 定义实现
 */
#include <fstream>

#include "pb_const.h"
#include "util/macro.h"
#include "util/string.h"

namespace {
static const std::vector<std::string> _indentation = {
    std::string(), std::string(INDENT_SPACE_NUM, ' '), std::string(2 * INDENT_SPACE_NUM, ' '),
    std::string(3 * INDENT_SPACE_NUM, ' '), std::string(4 * INDENT_SPACE_NUM, ' ')};

inline const char *INDENTATION(uint32_t tab_num) {
    COND_RET(tab_num < 5, _indentation[tab_num].c_str());
    return "";
}
}  // namespace

namespace pbc {

PbConst::~PbConst() {
    if (importer_)
        delete importer_;
}

std::map<std::string, PbConst::CmdHandler> PbConst::cmd_handler_map_ = {
    {"@pbc_declare", PbConst::handle_common_cmd}, {"@pbc_node", PbConst::handle_common_cmd},
    {"@pbc_type", PbConst::handle_common_cmd},    {"@pbc_code", PbConst::handle_common_cmd},
    {"@pbc_len", PbConst::handle_common_cmd},     {"@pbc_fix", PbConst::handle_common_cmd},
    {"@pbc_key", PbConst::handle_common_cmd},     {"@pbc_vector", PbConst::handle_common_cmd},
};

int PbConst::Init(const std::string &proto_filepath, const std::vector<std::string> &proto_file_path,
                  const std::string &out_file_path, const std::string &out_file_name) {
    auto pos = proto_filepath.find_last_of('/');
    if (pos != std::string::npos)
        proto_filename_ = proto_filepath.substr(pos + 1);
    else
        proto_filename_ = proto_filepath;
    OUTPUT_INFO("src:%s|file_name:%s", proto_filepath.c_str(), proto_filename_.c_str());

    if (!out_file_name.empty())
        out_file_name_ = out_file_name;
    else
        out_file_name_ = proto_filename_.substr(0, proto_filename_.find_first_of('.'));

    out_file_path_.assign(out_file_path);
    OUTPUT_DEBUG("cpp out path: %s", out_file_path_.c_str());

    COND_RET(out_file_name_.empty(), false);
    out_hd_filepath_ = out_file_path_ + "/" + out_file_name_ + out_hd_file_postfix_;
    out_cc_filepath_ = out_file_path_ + "/" + out_file_name_ + out_cc_file_postfix_;
    OUTPUT_INFO("output: %s, %s", out_hd_filepath_.c_str(), out_cc_filepath_.c_str());

    src_tree_.MapPath("", "./");  // 默认加入当前目录
    // 支持 ":" 分隔符
    for (std::size_t i = 0; i < proto_file_path.size(); ++i) {
        std::string curr_proto_path = proto_file_path[i];
        while (true) {
            auto pos = curr_proto_path.find(":");
            if (pos == std::string::npos) {
                src_tree_.MapPath("", curr_proto_path);
                proto_paths_.emplace_back(curr_proto_path);
                OUTPUT_DEBUG("proto path: %s", curr_proto_path.c_str());
                break;
            } else {
                src_tree_.MapPath("", curr_proto_path.substr(0, pos));
                proto_paths_.emplace_back(curr_proto_path.substr(0, pos));
                OUTPUT_DEBUG("proto path: %s", curr_proto_path.substr(0, pos).c_str());
                curr_proto_path = curr_proto_path.substr(pos + 1);
            }
        }
    }

    importer_ = new pb::compiler::Importer(&src_tree_, &error_collector_);
    COND_RET_ELOG(!importer_, ErrorCode::PROCESS_FAILURE, "init importer failed");

    file_desc_ = importer_->Import(proto_filename_);
    COND_EXP_ELOG(!file_desc_, error_collector_.PrintError();
                  return ErrorCode::PROCESS_FAILURE, "cannot open proto file|file:%s", proto_filename_.c_str());

    auto ret = CheckOnInit();
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::Parse() {
    int ret = ErrorCode::PROCESS_SUCCESS;

    // check declare
    std::string declare_code_block;
    COND_RET_ILOG(!CheckFileAndGetDeclarationCode(file_desc_, declare_code_block), ErrorCode::PROCESS_SUCCESS,
                  "skip no declaring file|file:%s", proto_filename_.c_str());

    // context
    std::stringstream context;
    OUTPUT(context,
           "/*\n"
           " * This file is generated by `pbc`. SOURCE PROTO FILE: %s\n"
           " * DO NOT CHANGE IT DIRECTLY, CHANGE SOURCE PROTO FILE INSTEADLY.\n"
           " */\n\n",
           proto_filename_.c_str());

    ss_hd_ << context.str();
    ss_cc_ << context.str();

    // #pragma
    OUTPUT(ss_hd_, "#pragma once\n\n");
    // #include
    OUTPUT(ss_hd_, "#include \"%s.pb.h\"\n",
           proto_filename_.substr(0, proto_filename_.size() - PB_POSTFIX_LEN).c_str());

    // process dependency
    ret = for_each_dependency(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    OUTPUT(ss_hd_, "\n");
    OUTPUT(ss_cc_, "#include \"%s%s\"\n\n", out_file_name_.c_str(), out_hd_file_postfix_.c_str());

    COND_EXP(!declare_code_block.empty(), OUTPUT(ss_hd_, "%s\n", declare_code_block.c_str()));
    OUTPUT(ss_hd_, "\n");

    // process namespace
    ret = handle_package(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);
    OUTPUT(ss_hd_, "\n");
    OUTPUT(ss_cc_, "\n");

    // process enum
    ret = for_each_enum(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);
    OUTPUT(ss_hd_, "\n");

    ret = for_each_message(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    // 将 @pbc_code 生成的代码写入头文件
    COND_EXP(!ss_pbc_code_.str().empty(), ss_hd_ << ss_pbc_code_.str() << std::endl);

    // 将前置类型声明写入头文件
    COND_EXP(!ss_declaration_.str().empty(), ss_hd_ << ss_declaration_.str() << std::endl);

    // 将文件级别 enum 写入头文件
    COND_EXP(!ss_enum_.str().empty(), ss_hd_ << ss_enum_.str() << std::endl);

    // 将结构体声明写入头文件
    COND_EXP(!ss_struct_def_.str().empty(), ss_hd_ << ss_struct_def_.str() << std::endl);

    // namespace 结束
    std::vector<std::string> nss;
    pbc::split(pbc_namespace_, CXX_NS_DELIMS, nss);
    for (std::size_t i = namespace_num_; i > 0; --i) {
        std::string ns = (i > nss.size() ? "" : " " + nss[i - 1]);
        OUTPUT(ss_hd_, "}  // namespace%s\n", ns.c_str());
        OUTPUT(ss_cc_, "}  // namespace%s\n", ns.c_str());
    }

    // 写入文件
    ret = write_file(ss_hd_, out_hd_filepath_);
    COND_RET_ELOG(ret != ErrorCode::PROCESS_SUCCESS, ret, "write file failed|out_file:%s|ret:%d",
                  out_hd_filepath_.c_str(), ret);

    ret = write_file(ss_cc_, out_cc_filepath_);
    COND_RET_ELOG(ret != ErrorCode::PROCESS_SUCCESS, ret, "write file failed|out_file:%s|ret:%d",
                  out_cc_filepath_.c_str(), ret);

    return ret;
}

int PbConst::handle_dependency(const pb::FileDescriptor *file_desc, const pb::FileDescriptor *dep_desc) {
    std::string code_block;
    COND_RET(!CheckFileAndGetDeclarationCode(dep_desc, code_block), ErrorCode::PROCESS_SUCCESS);

    std::string dep_name = dep_desc->name();
    if ((dep_name.size() > PB_POSTFIX_LEN) && (dep_name.substr(dep_name.size() - PB_POSTFIX_LEN) == ".proto")) {
        dep_name.resize(dep_name.size() - PB_POSTFIX_LEN);
        OUTPUT(ss_hd_, "#include \"%s%s\"\n", dep_name.c_str(), out_hd_file_postfix_.c_str());
    } else {
        OUTPUT_ERROR("proto filename postfix should be .proto|file:%s\n", dep_name.c_str());
        return ErrorCode::PROCESS_FAILURE;
    }

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_package(const pb::FileDescriptor *file_desc) {
    std::string pkg_string = file_desc->package();
    while (pkg_string.size()) {
        std::string add_ns;
        auto pos = pkg_string.find('.');
        if (pos == std::string::npos) {
            add_ns = pkg_string;
            pkg_string.clear();
        } else {
            add_ns = pkg_string.substr(0, pos);
            pkg_string = pkg_string.substr(pos + 1);
        }
        push_namespace(message_namespace_, add_ns);

        COND_EXP(pkg_string.empty(), add_ns = "pbc");
        push_namespace(pbc_namespace_, add_ns);

        OUTPUT(ss_hd_, "namespace %s {\n", add_ns.c_str());
        OUTPUT(ss_cc_, "namespace %s {\n", add_ns.c_str());
        ++namespace_num_;
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_enum(const pb::FileDescriptor *file_desc, const pb::EnumDescriptor *enum_desc) {
    // 如果需要生成 enum 代码，额外开一个 stringstream 来存，最后按照次序写入头文件
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_enum(const pb::Descriptor *msg_desc, const pb::EnumDescriptor *enum_desc) {
    return generate_enum(enum_desc, ss_struct_def_, 1);
}

int PbConst::handle_message(const pb::FileDescriptor *file_desc, const pb::Descriptor *msg_desc) {
    OUTPUT_DEBUG("START HANDLE Message: %s", msg_desc->name().c_str());
    int ret;
    // name
    std::string struct_name = get_type_name(msg_desc->name());

    // 检查 pbc_node，默认不生成 struct
    std::string msg_comment;
    COND_RET(!CheckMessageAndGetComment(msg_desc, msg_comment), ErrorCode::PROCESS_NONE);

    // 检查文件和 message 的依赖性
    std::string err_msg;
    COND_RET_ELOG(!CheckMessageDependency(msg_desc, &err_msg), ErrorCode::PROCESS_FAILURE,
                  "dependency check failed|error: \"%s\"", err_msg.c_str());

    // 检查 field 的参数是否合法
    COND_RET(!CheckFieldProperties(msg_desc), ErrorCode::PROCESS_FAILURE);

    // 前置声明
    OUTPUT(ss_declaration_, "struct %s;\n", struct_name.c_str());

    // message 注释
    COND_EXP(!msg_comment.empty(), OUTPUT(ss_struct_def_, "%s\n", msg_comment.c_str()));

    // 类声明开始
    OUTPUT(ss_struct_def_, "struct %s {\n", struct_name.c_str());

    // 把自定义代码输出
    generate_class_pbc_code(msg_desc);

    // message 内部嵌套类
    ret = for_each_nested(msg_desc);
    COND_RET_ELOG(ret != ErrorCode::PROCESS_SUCCESS, ret, "    trace file[%s]", file_desc->name().c_str());

    // message 内部 enum 声明
    ret = for_each_enum(msg_desc);
    COND_RET_ELOG(ret != ErrorCode::PROCESS_SUCCESS, ret, "    trace file[%s]", file_desc->name().c_str());

#define GENERATE_CODE(callFunc)                                                                                        \
    {                                                                                                                  \
        ret = callFunc(msg_desc);                                                                                      \
        COND_RET_ELOG(ret != ErrorCode::PROCESS_SUCCESS, ErrorCode::PROCESS_FAILURE, #callFunc " failed|ret:%d", ret); \
    }

    // 生成成员变量
    GENERATE_CODE(generate_member_var);

    // 生成构造函数
    GENERATE_CODE(generate_construct_func);

    // 生成 Clean 函数
    GENERATE_CODE(generate_clean_func);

    // 生成 FromPb 函数
    GENERATE_CODE(generate_frompb_func);

    // 生成 ToPb 函数
    GENERATE_CODE(generate_topb_func);

    // 普通结构的 Get 函数
    GENERATE_CODE(generate_get_func);

    // 普通结构的 Set 函数
    GENERATE_CODE(generate_set_func);

    // 为所有 repeated 结构生成 Size 函数
    GENERATE_CODE(generate_repeated_size_func);

    // 为所有 repeated 结构生成 Get 函数
    GENERATE_CODE(generate_repeated_get_func);

    // 为所有 repeated 结构生成 Set 函数
    GENERATE_CODE(generate_repeated_set_func);

    // 为所有 repeated 结构生成 Add 函数
    GENERATE_CODE(generate_repeated_add_func);

    // 为所有 repeated 结构生成 Del 函数
    GENERATE_CODE(generate_repeated_del_func);

    // 为所有 repeated 结构生成 DelByKey 函数
    GENERATE_CODE(generate_repeated_del_by_key_func);

    // 为所有 repeated 结构生成 delbatch 函数
    GENERATE_CODE(generate_repeated_del_batch_func);

    // 为所有 repeated 结构生成 find by key 函数
    GENERATE_CODE(generate_repeated_find_func);

    // 为所有 repeated 结构生成 Swap 函数
    GENERATE_CODE(generate_repeated_swap_func);

    // 为所有 repeated 结构生成 is_full 函数
    GENERATE_CODE(generate_repeated_full_func);

    // 为所有 repeated 结构生成 is_empty 函数
    GENERATE_CODE(generate_repeated_empty_func);

    // 生成 ShortDebugString 函数
    GENERATE_CODE(generate_debugstring_func);

    // 为这个 message 生成 key 比较函数，如果有的话
    GENERATE_CODE(generate_key_compare_func);

    // 为所有整形添加和减函数，默认 +1
    GENERATE_CODE(generate_inc_and_dec_func);

    // 为所有成员变量生成 clear 函数
    GENERATE_CODE(generate_clear_member_func);

#undef GENERATE_CODE

    // 类声明结束
    OUTPUT(ss_struct_def_, "};\n\n");

    return ErrorCode::PROCESS_SUCCESS;
}  // namespace pbc

int PbConst::handle_nested(const pb::Descriptor *msg_desc, const pb::Descriptor *nested_desc) {
    OUTPUT_STDERR("Sorry, pbc does not support nested message currently, please shift it out to continue.");
    OUTPUT_ERROR("message:%s|nested:%s", msg_desc->name().c_str(), nested_desc->name().c_str());
    return ErrorCode::PROCESS_FAILURE;
}

int PbConst::CheckOnInit() const {
    for (std::size_t i = 0; i < type_vector.size(); ++i)
        COND_RET_ELOG(type_vector[i].pb_cpp_type != static_cast<int>(i), ErrorCode::PROCESS_FAILURE,
                      "type vector pb_cpp_type wrong|pb_cpp_type:%d|index:%zu", type_vector[i].pb_cpp_type, i);
    return ErrorCode::PROCESS_SUCCESS;
}

bool PbConst::CheckFileAndGetDeclarationCode(const pb::FileDescriptor *file_desc, std::string &code_block) const {
    int ret = ErrorCode::PROCESS_SUCCESS;
    pb::FileDescriptorProto file_proto;
    file_desc->CopySourceCodeInfoTo(&file_proto);
    const pb::SourceCodeInfo *src_info = &file_proto.source_code_info();

    for (const auto &loc : file_proto.source_code_info().location()) {
        if ((loc.path_size() == 1 && loc.path(0) == 2) ||  // import
            (loc.path_size() == 2 && loc.path(0) == 3)) {  // package
            if (!loc.leading_comments().empty()) {
                std::string src = loc.leading_comments();
                std::string attachment;
                ret = handle_common_cmd("@pbc_declare", src, attachment);
                COND_EXP(ret == ErrorCode::PROCESS_SUCCESS, std::swap(code_block, src); return true);
            }
        }
    }
    return false;
}

bool PbConst::CheckMessageAndGetComment(const pb::Descriptor *msg_desc, std::string &comment) const {
    pb::SourceLocation loc;
    msg_desc->GetSourceLocation(&loc);
    comment.clear();

    if (!loc.leading_comments.empty()) {
        std::string src = loc.leading_comments;
        std::string attachment;
        int ret = handle_common_cmd("@pbc_node", src, attachment);
        if (ret == ErrorCode::PROCESS_SUCCESS) {
            if (!src.empty()) {
                // 过滤掉 pbc_code 的部分
                std::string pbc_code_block;
                handle_common_cmd("@pbc_code", src, pbc_code_block);
                generate_comment(src, comment, 0, false);
            }
            return true;
        }
    }
    return false;
}

bool PbConst::CheckMessageDependency(const pb::Descriptor *msg_desc, std::string *err_msg) const {
    std::string comment;
    if (!CheckFileAndGetDeclarationCode(msg_desc->file(), comment)) {
        err_msg->assign("file: " + msg_desc->file()->name() + " should add @pbc_declare");
        return false;
    }
    if (!CheckMessageAndGetComment(msg_desc, comment)) {
        err_msg->assign(msg_desc->file()->name() + ":" + msg_desc->name() + " should add @pbc_node");
        return false;
    }
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_RET(field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE &&
                     !CheckMessageDependency(field_desc->message_type(), err_msg),
                 false);
    }
    return true;
}

bool PbConst::CheckFieldProperties(const pb::Descriptor *msg_desc) const {
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);

        std::string leading_comment, trailing_comment;
        std::map<std::string, std::string> cmds;

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, 1);

        // not support enum field
        COND_RET_ELOG(
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_ENUM, false,
            "pbc doesn't support enum_type field currently, change it to uint32 and try again|message:%s|enum:%s",
            msg_desc->name().c_str(), field_desc->name().c_str());
        // array must have @pbc_len or @pbc_fix
        bool is_array = (field_desc->is_repeated() || (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING));
        COND_RET_ELOG(is_array && !cmds.count("@pbc_len") && !cmds.count("@pbc_fix") && !cmds.count("@pbc_vector"),
                      false, "repeated or string field must has command @pbc_len or @pbc_fix|message:%s|field:%s",
                      msg_desc->name().c_str(), field_desc->name().c_str());
        // not support repeated string
        COND_RET_ELOG(field_desc->is_repeated() && (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING),
                      false, "sorry, pbc doesn't support repeated string field|message:%s|field:%s",
                      msg_desc->name().c_str(), field_desc->name().c_str())
    }

    return true;
}

int PbConst::handle_common_cmd(const std::string &cmd, std::string &src, std::string &attachment) {
    int ret = ErrorCode::PROCESS_SUCCESS;
    bool found = false;
    std::size_t pos;
    std::string line, new_src;
    attachment.clear();
    std::vector<std::string> src_lines;
    split(src, "\n", src_lines);

    for (std::size_t i = 0; i < src_lines.size(); ++i) {
        line.assign(pbc::trim(src_lines[i]));
        COND_EXP(line.empty(), continue);
        pos = line.find(cmd);
        if (pos != std::string::npos) {
            found = true;
            std::string temp = line.substr(pos + cmd.size());
            pbc::trim(temp);
            COND_EXP(temp.empty(), continue);
            attachment += (attachment.empty() ? temp : "\n" + temp);
        } else {
            new_src += (new_src.empty() ? line : "\n" + line);
        }
    }
    std::swap(src, new_src);  // 将 src 赋值为 new_src
    return found ? ErrorCode::PROCESS_SUCCESS : ErrorCode::PROCESS_FAILURE;
}

void PbConst::push_namespace(std::string &ns, const std::string &add_ns) {
    ns += (ns.empty() ? add_ns : CXX_NS_DELIMS + add_ns);
}

std::string PbConst::get_type_name(const std::string &proto_type_name) const {
    return "M" + proto_type_name;
}

std::string PbConst::get_field_type_name(const pb::FieldDescriptor *field_desc, const std::string &custom_type) const {
    switch (field_desc->cpp_type()) {
        case pb::FieldDescriptor::CPPTYPE_MESSAGE: {
            return get_type_name(field_desc->message_type()->name());
        }
        case pb::FieldDescriptor::CPPTYPE_INT32:
        case pb::FieldDescriptor::CPPTYPE_INT64:
        case pb::FieldDescriptor::CPPTYPE_UINT32:
        case pb::FieldDescriptor::CPPTYPE_UINT64: {
            if (custom_type.empty())
                return type_vector[field_desc->cpp_type()].cpp_type;
            else
                return custom_type;
        }
        case pb::FieldDescriptor::CPPTYPE_DOUBLE:
        case pb::FieldDescriptor::CPPTYPE_FLOAT:
        case pb::FieldDescriptor::CPPTYPE_BOOL:
        case pb::FieldDescriptor::CPPTYPE_STRING: {
            return type_vector[field_desc->cpp_type()].cpp_type;
        }
        default: {
            OUTPUT_ERROR("bad protobuf cpp type|pb_cpp_type:%u", field_desc->cpp_type());
            break;
        }
    }
    return "";
}

void PbConst::set_repeated_limit_value(const std::string &field_name, const std::string &value) {
    std::string max_count{field_name};
    std::transform(max_count.begin(), max_count.end(), max_count.begin(), ::toupper);
    repeated_limit_value_map_[max_count + LIMIT_COUNT_POSTFIX] = value;
}

std::string PbConst::get_repeated_limit(const std::string &field_name) const {
    std::string max_count{field_name};
    std::transform(max_count.begin(), max_count.end(), max_count.begin(), ::toupper);
    return max_count + LIMIT_COUNT_POSTFIX;
}

std::string PbConst::get_repeated_limit_value(const std::string &field_name) const {
    std::string max_count{field_name};
    std::transform(max_count.begin(), max_count.end(), max_count.begin(), ::toupper);
    auto iter = repeated_limit_value_map_.find(max_count + LIMIT_COUNT_POSTFIX);
    COND_RET(iter == repeated_limit_value_map_.end(), "0");
    return iter->second;
}

int PbConst::write_file(std::stringstream &ss, const std::string &filepath) const {
    COND_RET(ss.str().empty(), ErrorCode::PROCESS_SUCCESS);
    ::remove(filepath.c_str());
    std::ofstream ofs;
    ofs.open(filepath.c_str(), std::ios::out | std::ios::trunc);
    COND_RET_ELOG(ofs.fail(), ErrorCode::PROCESS_FAILURE, "open out filepath failed|out_path:%s", filepath.c_str());
    ofs << ss.str();
    ofs.close();
    return ErrorCode::PROCESS_SUCCESS;
}

void PbConst::generate_class_pbc_code(const pb::Descriptor *msg_desc) {
    pb::SourceLocation loc;
    msg_desc->GetSourceLocation(&loc);
    if (!loc.leading_comments.empty()) {
        std::string cmd = "@pbc_code";
        std::vector<std::string> src_lines;
        split(loc.leading_comments, "\n", src_lines);
        for (size_t i = 0; i < src_lines.size(); ++i) {
            std::string line = pbc::trim(src_lines[i]);
            COND_EXP(line.empty(), continue);
            size_t pos = line.find(cmd);
            COND_EXP(pos == std::string::npos, continue);
            // std::string temp = line.substr(pos + cmd.length());
            // OUTPUT(ss_struct_def_, "%s\n", temp.c_str());
            OUTPUT(ss_struct_def_, "%s\n", line.substr(pos + cmd.size()).c_str());
        }
    }
}

int PbConst::generate_enum(const pb::EnumDescriptor *enum_desc, std::stringstream &ss, int tab_num) {
    OUTPUT_DEBUG("    START HANDLE ENUM|MessageEnum:%s", enum_desc->name().c_str());
    std::string src;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;
    std::string enum_name = get_type_name(enum_desc->name());

    pb::SourceLocation loc;
    enum_desc->GetSourceLocation(&loc);
    handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
    COND_EXP(!leading_comment.empty(), OUTPUT(ss, "%s\n", leading_comment.c_str()));
    OUTPUT(ss, "%senum %s\n%s{\n", INDENTATION(tab_num), enum_name.c_str(), INDENTATION(tab_num));

    for (int i = 0; i < enum_desc->value_count(); ++i) {
        const auto *value_desc = enum_desc->value(i);
        // comment
        pb::SourceLocation value_loc;
        value_desc->GetSourceLocation(&value_loc);

        handle_field_comment(value_loc, cmds, leading_comment, trailing_comment, tab_num + 1);
        COND_EXP(!leading_comment.empty(), OUTPUT(ss, "%s\n", leading_comment.c_str()));
        OUTPUT(ss, "%s    %s = %d,", INDENTATION(tab_num), value_desc->name().c_str(), value_desc->number());
        COND_EXP(!trailing_comment.empty(), OUTPUT(ss, "%s", trailing_comment.c_str()));
        OUTPUT(ss, "\n");
    }
    OUTPUT(ss, "%s};\n", INDENTATION(tab_num));
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_member_var(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;
    OUTPUT_DEBUG("    START HANDLE MEMBER VARIABILE");

    OUTPUT(ss_struct_def_, "private:\n");
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        std::string type_name = get_field_type_name(field_desc, cmds["@pbc_type"]);
        bool is_array = (field_desc->is_repeated() || (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING));
        bool is_nested_message = (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE);

        // @pbc_code source
        COND_EXP(cmds.count("@pbc_code"), OUTPUT(ss_pbc_code_, "%s\n", cmds["@pbc_code"].c_str()));
        // @pbc_key  // 这个成员将作为查找的一个key
        if (cmds.count("@pbc_key")) {
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                // 对于 message 类型，调用 message 的 eq_ref 函数
                OUTPUT(ss_eq_key_def_, "%sif (!%s_.eq_ref(_%s))\n%sreturn false;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), field_desc->name().c_str(), INDENTATION(tab_num + 1));
                OUTPUT(ss_ref_key_def_, "%sif (!%s_.eq_ref(ref.%s_))\n%sreturn false;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), field_desc->name().c_str(), INDENTATION(tab_num + 1));
                if (eq_key_args_.size() > 0) {  // 把 eq_key 函数的参数记下来, message 用引用吧
                    eq_key_args_ += ", const " + type_name + " &_" + field_desc->name();
                } else {
                    eq_key_args_ = "const " + type_name + " &_" + field_desc->name();
                }
            } else {  // 普通类型，直接使用 = 符号
                OUTPUT(ss_eq_key_def_, "%sif (%s_ != _%s)\n%sreturn false;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), field_desc->name().c_str(), INDENTATION(tab_num + 1));
                OUTPUT(ss_ref_key_def_, "%sif (%s_ != ref.%s())\n%sreturn false;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), field_desc->name().c_str(), INDENTATION(tab_num + 1));
                if (eq_key_args_.size() > 0) {  // 把eq_key函数的参数记下来
                    eq_key_args_ += ", " + type_name + " _" + field_desc->name();
                } else {
                    eq_key_args_ = type_name + " _" + field_desc->name();
                }
            }
        }
        // member declaration
        COND_EXP(!leading_comment.empty(), OUTPUT(ss_struct_def_, "%s\n", leading_comment.c_str()));
        if (is_array) {
            // 没有设置 pbc_fix 定长就生成记录使用数量的字段
            if (!cmds.count("@pbc_fix") && !cmds.count("@pbc_vector")) {
                OUTPUT(ss_struct_def_, "%suint32_t %s_num_ = 0;\n", INDENTATION(tab_num), field_desc->name().c_str());
            }

            std::string max_len;
            std::string cmd_str;
            // 如果定义了@pbc_fix 或者@pbc_len，两者起码有一个确定了最大长度
            COND_EXP(cmds.count("@pbc_fix"), cmd_str = cmds["@pbc_fix"]);
            COND_EXP(cmds.count("@pbc_len"), cmd_str = cmds["@pbc_len"]);
            COND_EXP(cmds.count("@pbc_vector"), cmd_str = cmds["@pbc_vector"]);
            size_t pos = cmd_str.find('=');  // 如果没有 `=` 在 proto 中定义了具体的数字，则直接用注释的内容
            if (pos == std::string::npos) {
                max_len = pbc::trim(cmd_str);
            } else {  // 有 `=`，说明给出了具体的数值，没定义对应的宏
                std::string sub_str = cmd_str.substr(pos + 1);
                max_len = pbc::trim(sub_str);  // 截取后面的数字
            }
            // char 数组类型，多一个字节放空格
            if (field_desc->type() == pb::FieldDescriptor::TYPE_BYTES ||
                field_desc->type() == pb::FieldDescriptor::TYPE_STRING) {
                max_len += " + 1";
            }

            OUTPUT_DEBUG("max_len:%s", max_len.c_str());
            std::string max_count = get_repeated_limit(field_desc->name());  // 定义对应的static const 变量
            // 定义一个在对应命名空间下的 static const
            OUTPUT(ss_struct_def_, "%sstatic const uint32_t %s = %s;\n", INDENTATION(tab_num), max_count.c_str(),
                   max_len.c_str());

            set_repeated_limit_value(field_desc->name(), max_len);
            if (cmds.count("@pbc_vector")) {
                OUTPUT(ss_struct_def_, "%susing fixed_vector_%s_type = FixedVector<%s,%s>;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), type_name.c_str(), max_len.c_str());
                OUTPUT(ss_struct_def_, "%sfixed_vector_%s_type %s_;\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), field_desc->name().c_str());
            } else if (field_desc->cpp_type() != pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                // 这里直接用 max_len, 如果是数组，不定义 pbc_fix
                // 或者 pbc_len 本来就是不对的，让这个问题在编译的时候报错
                OUTPUT(ss_struct_def_, "%s%s %s_[%s] = {0};\n", INDENTATION(tab_num), type_name.c_str(),
                       field_desc->name().c_str(), max_len.c_str());
            } else {
                // 这里直接用 max_len, 如果是数组，不定义 pbc_fix
                // 或者 pbc_len 本来就是不对的，让这个问题在编译的时候报错
                OUTPUT(ss_struct_def_, "%s%s %s_[%s];\n", INDENTATION(tab_num), type_name.c_str(),
                       field_desc->name().c_str(), max_len.c_str());
            }
        } else if (is_nested_message) {
            OUTPUT(ss_struct_def_, "%s%s %s_;", INDENTATION(tab_num), type_name.c_str(), field_desc->name().c_str());
        } else {
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_BOOL) {
                OUTPUT(ss_struct_def_, "%s%s %s_ = false;", INDENTATION(tab_num), type_name.c_str(),
                       field_desc->name().c_str());
            } else {
                OUTPUT(ss_struct_def_, "%s%s %s_ = 0;", INDENTATION(tab_num), type_name.c_str(),
                       field_desc->name().c_str());
            }
        }
        COND_EXP(!trailing_comment.empty(), OUTPUT(ss_struct_def_, "%s", trailing_comment.c_str()));
        OUTPUT(ss_struct_def_, "\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_construct_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    OUTPUT_DEBUG("    START HANDLE CONSTRUCT FUNC");
    std::string struct_name = get_type_name(msg_desc->name());
    OUTPUT(ss_struct_def_, "public:\n");
    OUTPUT(ss_struct_def_, "%s%s() = default;\n", INDENTATION(tab_num), struct_name.c_str());

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_clean_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    OUTPUT_DEBUG("    START HANDLE CLEAN FUNC");

    std::string struct_name = get_type_name(msg_desc->name());
    OUTPUT(ss_struct_def_, "    void Clean();\n");
    OUTPUT(ss_cc_, "void %s::Clean() {\n", struct_name.c_str());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        bool is_array = (field_desc->is_repeated() || (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING));
        if (is_array) {
            COND_EXP(cmds.count("@pbc_vector"),
                     OUTPUT(ss_cc_, "%s%s_.clear();\n", INDENTATION(tab_num), field_desc->name().c_str());
                     continue);
            COND_EXP(!cmds.count("@pbc_fix"),
                     OUTPUT(ss_cc_, "%s%s_num_ = 0;\n", INDENTATION(tab_num), field_desc->name().c_str()))
            OUTPUT(ss_cc_, "%smemset(%s_, 0, sizeof(%s_));\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   field_desc->name().c_str());
        } else {
            if (field_desc->cpp_type() != pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%s%s_ = 0;\n", INDENTATION(tab_num), field_desc->name().c_str());
            } else {
                OUTPUT(ss_cc_, "%smemset(&%s_, 0, sizeof(%s_));\n", INDENTATION(tab_num), field_desc->name().c_str(),
                       field_desc->name().c_str());
            }
        }
    }
    OUTPUT(ss_cc_, "}\n\n");
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_frompb_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    OUTPUT_DEBUG("    START HANDLE FromPb Func");

    std::string struct_name = get_type_name(msg_desc->name());
    OUTPUT(ss_struct_def_, "    bool FromPb(const %s::%s &pf, std::string *errmsg = nullptr);\n",
           message_namespace_.c_str(), msg_desc->name().c_str());
    // method FromPb
    OUTPUT(ss_cc_, "bool %s::FromPb(const %s::%s &pf, std::string *errmsg) {\n", struct_name.c_str(),
           message_namespace_.c_str(), msg_desc->name().c_str());
    OUTPUT(ss_cc_, "%sbool _bret = true;\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%sClean();\n", INDENTATION(tab_num));

    const auto &msg_name = msg_desc->name();
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        const auto field_name = field_desc->name();

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        std::string lower_name = field_desc->name();
        // protobuf 的接口都是小写的，大写的变量会编不过
        std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);
        // frompb
        if (field_desc->is_repeated()) {
            OUTPUT(ss_cc_, "%sif (static_cast<uint32_t>(pf.%s_size()) > %s) {\n", INDENTATION(tab_num),
                   lower_name.c_str(), get_repeated_limit(field_name).c_str());
            OUTPUT(ss_cc_, "%sif (errmsg)\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%serrmsg->assign(\"%s.%s size bigger than max\");\n", INDENTATION(tab_num + 1),
                   msg_name.c_str(), field_name.c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%s}\n\n", INDENTATION(--tab_num));
            if (cmds.count("@pbc_vector")) {
                OUTPUT(ss_cc_, "%s%s_.resize(pf.%s_size());\n", INDENTATION(tab_num), field_name.c_str(),
                       lower_name.c_str());
            } else if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%s%s_num_ = pf.%s_size();\n", INDENTATION(tab_num), field_name.c_str(),
                       lower_name.c_str());
            }
            OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < static_cast<uint32_t>(pf.%s_size()); ++i)\n",
                   INDENTATION(tab_num), lower_name.c_str());
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%s_bret = _bret && %s_[i].FromPb(pf.%s(i), errmsg);\n\n", INDENTATION(tab_num + 1),
                       field_name.c_str(), lower_name.c_str());
            } else {
                OUTPUT(ss_cc_, "%s%s_[i] = pf.%s(i);\n\n", INDENTATION(tab_num + 1), field_name.c_str(),
                       lower_name.c_str());
            }
        } else {
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING) {
                OUTPUT(ss_cc_, "%s\n", INDENTATION(tab_num));
                OUTPUT(ss_cc_, "%sif (pf.%s().length() > %s) {\n", INDENTATION(tab_num), lower_name.c_str(),
                       get_repeated_limit(field_name).c_str());
                OUTPUT(ss_cc_, "%sif (errmsg)\n", INDENTATION(++tab_num));
                OUTPUT(ss_cc_, "%serrmsg->assign(\"%s.%s length bigger than max\");\n", INDENTATION(tab_num + 1),
                       msg_name.c_str(), field_name.c_str());
                OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num));
                OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));

                if (cmds.count("@pbc_fix")) {
                    OUTPUT(ss_cc_, "%spf.%s().copy(%s_, pf.%s().length());\n", INDENTATION(tab_num), lower_name.c_str(),
                           field_name.c_str(), lower_name.c_str());
                } else {
                    OUTPUT(ss_cc_, "%s%s_num_ = pf.%s().length();\n", INDENTATION(tab_num), field_name.c_str(),
                           lower_name.c_str());
                    OUTPUT(ss_cc_, "%spf.%s().copy(%s_, %s_num_);\n", INDENTATION(tab_num), lower_name.c_str(),
                           field_name.c_str(), field_name.c_str());
                }
                OUTPUT(ss_cc_, "\n");
            } else if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%sif (pf.has_%s())\n", INDENTATION(tab_num), lower_name.c_str());
                OUTPUT(ss_cc_, "%s_bret = _bret && %s_.FromPb(pf.%s(), errmsg);\n\n", INDENTATION(tab_num + 1),
                       field_name.c_str(), lower_name.c_str());
            } else {
                OUTPUT(ss_cc_, "%s%s_ = pf.%s();\n", INDENTATION(tab_num), field_desc->name().c_str(),
                       lower_name.c_str());
            }
        }
    }
    // method FromPb
    OUTPUT(ss_cc_, "%sreturn _bret;\n}\n\n", INDENTATION(tab_num));
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_topb_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    OUTPUT_DEBUG("    START HANDLE ToPb Func");

    std::string struct_name = get_type_name(msg_desc->name());
    OUTPUT(ss_struct_def_, "    bool ToPb(%s::%s *pf, std::string *errmsg = nullptr) const;\n",
           message_namespace_.c_str(), msg_desc->name().c_str());
    // method ToPb
    OUTPUT(ss_cc_, "bool %s::ToPb(%s::%s *pf, std::string *errmsg) const {\n", struct_name.c_str(),
           message_namespace_.c_str(), msg_desc->name().c_str());
    OUTPUT(ss_cc_, "%sif (pf == nullptr) {\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%sif (errmsg)\n", INDENTATION(++tab_num));
    OUTPUT(ss_cc_, "%serrmsg->assign(\"pointer nullptr\");\n", INDENTATION(++tab_num));
    OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(--tab_num));
    OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
    OUTPUT(ss_cc_, "%sbool _bret = true;\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%spf->Clear();\n", INDENTATION(tab_num));

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        std::string lower_name = field_desc->name();
        std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);
        // topb
        if (field_desc->is_repeated()) {
            if (cmds.count("@pbc_vector")) {
                OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s_.size(); ++i)\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            } else if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s_num_ && i < %s; ++i)\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            } else {
                OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s; ++i)\n", INDENTATION(tab_num),
                       get_repeated_limit(field_desc->name()).c_str());
            }
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%s_bret = _bret && %s_[i].ToPb(pf->mutable_%s()->Add(), errmsg);\n\n",
                       INDENTATION(tab_num + 1), field_desc->name().c_str(), lower_name.c_str());
            } else {
                OUTPUT(ss_cc_, "%spf->mutable_%s()->Add(%s_[i]);\n\n", INDENTATION(tab_num + 1), lower_name.c_str(),
                       field_desc->name().c_str());
            }
        } else {
            if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING) {
                if (cmds.count("@pbc_fix")) {
                    OUTPUT(ss_cc_, "%spf->set_%s(%s_, %s);\n", INDENTATION(tab_num), lower_name.c_str(),
                           field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
                } else {
                    OUTPUT(ss_cc_, "%spf->set_%s(%s_, %s_num_);\n", INDENTATION(tab_num), lower_name.c_str(),
                           field_desc->name().c_str(), field_desc->name().c_str());
                }
            } else if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%s_bret = _bret && %s_.ToPb(pf->mutable_%s(), errmsg);\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), lower_name.c_str());
            } else {
                OUTPUT(ss_cc_, "%spf->set_%s(%s_);\n", INDENTATION(tab_num), lower_name.c_str(),
                       field_desc->name().c_str());
            }
        }
    }
    // method ToPb
    OUTPUT(ss_cc_, "%sreturn _bret;\n}\n\n", INDENTATION(tab_num));
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_get_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(field_desc->is_repeated() && !cmds.count("@pbc_vector"), continue);
        // size
        OUTPUT_DEBUG("    START HANDLE Func: get_%s", field_desc->name().c_str());
        if (cmds.count("@pbc_vector")) {
            OUTPUT(ss_struct_def_, "    const fixed_vector_%s_type &%s() const;\n", field_desc->name().c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    fixed_vector_%s_type *mutable_%s();\n", field_desc->name().c_str(),
                   field_desc->name().c_str());

            OUTPUT(ss_cc_, "const %s::fixed_vector_%s_type &%s::%s() const {\n", struct_name.c_str(),
                   field_desc->name().c_str(), struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");

            OUTPUT(ss_cc_, "%s::fixed_vector_%s_type *%s::mutable_%s() {\n", struct_name.c_str(),
                   field_desc->name().c_str(), struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn &%s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING) {
            if (!cmds.count("@pbc_fix")) {
                // bytes字段生成get_num函数
                OUTPUT(ss_struct_def_, "    uint32_t %s_num() const;\n", field_desc->name().c_str());
                OUTPUT(ss_cc_, "uint32_t %s::%s_num() const {\n", struct_name.c_str(), field_desc->name().c_str());
                OUTPUT(ss_cc_, "%sreturn %s_num_;\n", INDENTATION(tab_num), field_desc->name().c_str());
                OUTPUT(ss_cc_, "}\n\n");
            }
            OUTPUT(ss_struct_def_, "    const char *%s() const;\n", field_desc->name().c_str());
            OUTPUT(ss_cc_, "const char *%s::%s() const {\n", struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");

            OUTPUT(ss_struct_def_, "    char *mutable_%s();\n", field_desc->name().c_str());
            OUTPUT(ss_cc_, "char *%s::mutable_%s() {\n", struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
            OUTPUT(ss_struct_def_, "    const %s &%s() const;\n", get_field_type_name(field_desc, "").c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %s *mutable_%s();\n", get_field_type_name(field_desc, "").c_str(),
                   field_desc->name().c_str());

            OUTPUT(ss_cc_, "const %s &%s::%s() const {\n", get_field_type_name(field_desc, "").c_str(),
                   struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");

            OUTPUT(ss_cc_, "%s *%s::mutable_%s() {\n", get_field_type_name(field_desc, "").c_str(), struct_name.c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn &%s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else {
            OUTPUT(ss_struct_def_, "    const %s &%s() const;\n",
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "const %s &%s::%s() const {\n", get_field_type_name(field_desc, cmds["@pbc_type"]).c_str(),
                   struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_set_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(field_desc->is_repeated(), continue);
        COND_EXP(field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE, continue);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        // size
        OUTPUT_DEBUG("    START HANDLE set_%s Func", field_desc->name().c_str());

        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING) {
            // set_xxx(const char * value, uint32_t len)
            OUTPUT(ss_struct_def_, "    bool set_%s(const char * value, uint32_t len);\n", field_desc->name().c_str());
            OUTPUT(ss_cc_, "bool %s::set_%s(const char * value, uint32_t len) {\n", struct_name.c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sif (len >= %s)\n", INDENTATION(tab_num), get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%smemset(%s_, 0, sizeof(%s_));\n", INDENTATION(--tab_num), field_desc->name().c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%smemcpy(%s_, value, len);\n", INDENTATION(tab_num), field_desc->name().c_str());
            COND_EXP(!cmds.count("@pbc_fix"),
                     OUTPUT(ss_cc_, "%s%s_num_ = len;\n", INDENTATION(tab_num), field_desc->name().c_str()));
            OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "}\n\n");

            // 需要设置长度, 禁止char*单参数自动转换string调用下面string版
            OUTPUT(ss_struct_def_, "    bool set_%s(const char * value) = delete;\n\n", field_desc->name().c_str());

            // 适配一个string版,方便使用,set_xxx(const std::string& value)
            OUTPUT(ss_struct_def_, "    bool set_%s(const std::string& value);\n", field_desc->name().c_str());
            OUTPUT(ss_cc_, "bool %s::set_%s(const std::string& value) {\n", struct_name.c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn set_%s(value.c_str(), value.length());\n", INDENTATION(tab_num),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else {
            OUTPUT(ss_struct_def_, "    void set_%s(%s value);\n", field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
            OUTPUT(ss_cc_, "void %s::set_%s(%s value) {\n", struct_name.c_str(), field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
            OUTPUT(ss_cc_, "%s%s_ = value;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_size_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        // size
        OUTPUT_DEBUG("    START HANDLE Func: %s_size", field_desc->name().c_str());
        std::string max_count = get_repeated_limit(field_desc->name());
        OUTPUT(ss_struct_def_, "    uint32_t %s_size() const;\n", field_desc->name().c_str());
        OUTPUT(ss_cc_, "uint32_t %s::%s_size() const {\n", struct_name.c_str(), field_desc->name().c_str());
        if (cmds.count("@pbc_vector")) {
            OUTPUT(ss_cc_, "%sreturn %s_.size();\n", INDENTATION(tab_num), field_desc->name().c_str());
        } else if (!cmds.count("@pbc_fix")) {
            OUTPUT(ss_cc_, "%sreturn %s_num_ < %s ? %s_num_ : %s;\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   max_count.c_str(), field_desc->name().c_str(), max_count.c_str());
        } else {
            OUTPUT(ss_cc_, "%sreturn %s;\n", INDENTATION(tab_num), max_count.c_str());
        }
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_get_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        COND_EXP(field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING, continue);  // string不生成

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        // get
        OUTPUT_DEBUG("    START HANDLE Func: get_%s", field_desc->name().c_str());

        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
            OUTPUT(ss_struct_def_, "    const %s* %s(uint32_t idx) const;\n",
                   get_field_type_name(field_desc, "").c_str(), field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %s* mutable_%s(uint32_t idx);\n", get_field_type_name(field_desc, "").c_str(),
                   field_desc->name().c_str());

            OUTPUT(ss_cc_, "const %s* %s::%s(uint32_t idx) const {\n", get_field_type_name(field_desc, "").c_str(),
                   struct_name.c_str(), field_desc->name().c_str());
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || idx >= %s) {\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            } else {
                OUTPUT(ss_cc_, "%sif (idx >= %s) {\n", INDENTATION(tab_num),
                       get_repeated_limit(field_desc->name()).c_str());
            }
            OUTPUT(ss_cc_, "%sreturn nullptr;\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn &(%s_[idx]);\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");

            OUTPUT(ss_cc_, "%s* %s::mutable_%s(uint32_t idx) {\n", get_field_type_name(field_desc, "").c_str(),
                   struct_name.c_str(), field_desc->name().c_str());
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || idx >= %s) {\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            } else {
                OUTPUT(ss_cc_, "%sif (idx >= %s) {\n", INDENTATION(tab_num),
                       get_repeated_limit(field_desc->name()).c_str());
            }
            OUTPUT(ss_cc_, "%sreturn nullptr;\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn &(%s_[idx]);\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else {
            OUTPUT(ss_struct_def_, "    %s %s(uint32_t idx) const;\n",
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%s %s::%s(uint32_t idx) const {\n",
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str(), struct_name.c_str(),
                   field_desc->name().c_str());
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || idx >= %s) {\n", INDENTATION(tab_num),
                       field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            } else {
                OUTPUT(ss_cc_, "%sif (idx >= %s) {\n", INDENTATION(tab_num),
                       get_repeated_limit(field_desc->name()).c_str());
            }
            OUTPUT(ss_cc_, "%sreturn 0;\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn (%s_[idx]);\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_set_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        // message和string不生成
        COND_EXP(field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE ||
                     field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING,
                 continue);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        // set
        OUTPUT_DEBUG("    START HANDLE Func: set_%s", field_desc->name().c_str());

        OUTPUT(ss_struct_def_, "    bool set_%s(uint32_t idx, %s value);\n", field_desc->name().c_str(),
               get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
        OUTPUT(ss_cc_, "bool %s::set_%s(uint32_t idx, %s value) {\n", struct_name.c_str(), field_desc->name().c_str(),
               get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());

        if (!cmds.count("@pbc_fix")) {
            OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || idx >= %s) {\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   get_repeated_limit(field_desc->name()).c_str());
        } else {
            OUTPUT(ss_cc_, "%sif (idx >= %s) {\n", INDENTATION(tab_num),
                   get_repeated_limit(field_desc->name()).c_str());
        }

        OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(++tab_num));
        OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
        OUTPUT(ss_cc_, "%s%s_[idx] = value;\n", INDENTATION(tab_num), field_desc->name().c_str());
        OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_add_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        COND_EXP(field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING, continue);  // string不生成

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        // 固定长度数组没有add方法
        COND_EXP(cmds.count("@pbc_fix"), continue);
        COND_EXP(cmds.count("@pbc_vector"), continue);

        // add
        OUTPUT_DEBUG("    START HANDLE add_%s Func", field_desc->name().c_str());

        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
            OUTPUT(ss_struct_def_, "    %s* add_%s(uint32_t *pidx = nullptr);\n",
                   get_field_type_name(field_desc, "").c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%s* %s::add_%s(uint32_t *pidx) {\n", get_field_type_name(field_desc, "").c_str(),
                   struct_name.c_str(), field_desc->name().c_str());

            OUTPUT(ss_cc_, "%sif (%s_num_ >= %s)\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sreturn nullptr;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%s++%s_num_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sif (pidx != nullptr)\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%s*pidx = (%s_num_ - 1);\n", INDENTATION(tab_num + 1), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%smemset(&(%s_[%s_num_ - 1]), 0, sizeof(%s));\n", INDENTATION(tab_num),
                   field_desc->name().c_str(), field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
            OUTPUT(ss_cc_, "%sreturn &(%s_[%s_num_ - 1]);\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "}\n\n");
        } else {
            OUTPUT(ss_struct_def_, "    bool add_%s(%s value);\n", field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
            OUTPUT(ss_cc_, "bool %s::add_%s(%s value) {\n", struct_name.c_str(), field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());

            OUTPUT(ss_cc_, "%sif (%s_num_ >= %s)\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%s%s_[%s_num_] = value;\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%s++%s_num_;\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "}\n\n");
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_del_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        std::string type_name = get_field_type_name(field_desc, cmds["@pbc_type"]);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        // del
        OUTPUT_DEBUG("    START HANDLE Func: del_%s", field_desc->name().c_str());

        OUTPUT(ss_struct_def_, "    bool del_%s(uint32_t idx);\n", field_desc->name().c_str());
        OUTPUT(ss_cc_, "bool %s::del_%s(uint32_t idx) {\n", struct_name.c_str(), field_desc->name().c_str());
        if (!cmds.count("@pbc_fix")) {
            OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || idx >= %s)\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(++tab_num));
            // 不定长数组要将后面的节点往前拷贝
            OUTPUT(ss_cc_, "%suint32_t last_idx = %s_num_ < %s ? (%s_num_ - 1) : (%s - 1);\n", INDENTATION(--tab_num),
                   field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str(),
                   field_desc->name().c_str(), get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sif (idx < last_idx)\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%smemmove(&(%s_[idx]), &(%s_[idx + 1]), (last_idx - idx) * sizeof(%s));\n",
                   INDENTATION(tab_num + 1), field_desc->name().c_str(), field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
            OUTPUT(ss_cc_, "%s--%s_num_;\n", INDENTATION(tab_num), field_desc->name().c_str());
        } else {
            OUTPUT(ss_cc_, "%sif (idx >= %s)\n", INDENTATION(tab_num), get_repeated_limit(field_desc->name()).c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%smemset(&(%s_[idx]), 0, sizeof(%s));\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   get_field_type_name(field_desc, cmds["@pbc_type"]).c_str());
        }
        OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "}\n\n");

        COND_EXP(cmds.count("@pbc_vector"), continue);
        // 定义一个使用最后一个元素代替被删除元素的删除版本，仅对@pbc_len生效
        if (!cmds.count("@pbc_fix")) {
            OUTPUT(ss_struct_def_, "    bool del_mlast_%s(uint32_t idx);\n", field_desc->name().c_str());
            OUTPUT(ss_cc_, "bool %s::del_mlast_%s(uint32_t idx) {\n", struct_name.c_str(), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sif (idx >= %s || idx >= %s_num_)\n%sreturn false;\n", INDENTATION(tab_num),
                   get_repeated_limit(field_desc->name()).c_str(), field_desc->name().c_str(),
                   INDENTATION(tab_num + 1));
            // 如果不是最后一个
            OUTPUT(ss_cc_, "%sif (idx != %s_num_ - 1)\n", INDENTATION(tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%smemmove(&(%s_[idx]), &(%s_[%s_num_ - 1]), sizeof(%s));\n", INDENTATION(++tab_num),
                   field_desc->name().c_str(), field_desc->name().c_str(), field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "%s--%s_num_;\n", INDENTATION(--tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn true;\n}\n\n", INDENTATION(tab_num));
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_del_by_key_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string struct_name = get_type_name(msg_desc->name());
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        // del
        OUTPUT_DEBUG("    START HANDLE Func: del_%s", field_desc->name().c_str());
        // 先获取当前这个变量的类型，如果是message，需要定义对应的eq_key和eq_ref, 如果是string, 暂时还不支持
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_DOUBLE ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_FLOAT) {
            continue;  // 不支持 repeated string, repeated bytes 还有浮点数互相用 == 比较不安全，还是不自动生成了吧
        }

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        std::string type_name = get_field_type_name(field_desc, cmds["@pbc_type"]);

        COND_EXP(cmds.count("@pbc_vector"), continue);
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
            // 根据key删
            OUTPUT(ss_struct_def_, "\n    template <typename... Keys>\n");
            OUTPUT(ss_struct_def_, "    bool del_key_%s(const Keys... keys) {\n", field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sint32_t index = find_index_%s(keys...);\n", INDENTATION(tab_num),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sif (index != -1)\n", INDENTATION(tab_num));
            OUTPUT(ss_struct_def_, "    %sreturn del_%s(index);\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sreturn false;\n    }\n\n", INDENTATION(--tab_num));

            // 定义一个使用最后一个元素代替被删除元素的删除版本，仅对 @pbc_len 生效
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_struct_def_, "\n    template <typename... Keys>\n");
                OUTPUT(ss_struct_def_, "    bool del_mlast_key_%s(const Keys... keys) {\n", field_desc->name().c_str());
                OUTPUT(ss_struct_def_, "    %sint32_t index = find_index_%s(keys...);\n", INDENTATION(tab_num),
                       field_desc->name().c_str());
                OUTPUT(ss_struct_def_, "    %sif (index != -1)\n", INDENTATION(tab_num));
                OUTPUT(ss_struct_def_, "    %sreturn del_mlast_%s(index);\n", INDENTATION(++tab_num),
                       field_desc->name().c_str());
                OUTPUT(ss_struct_def_, "    %sreturn false;\n    }\n\n", INDENTATION(--tab_num));
            }
        } else  // 基础类型没有模板参数
        {
            OUTPUT(ss_struct_def_, "    bool del_key_%s(const %s keys);\n", field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "bool %s::del_key_%s(const %s keys) {\n", struct_name.c_str(), field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "%sint32_t index = find_index_%s(keys);\n", INDENTATION(tab_num),
                   field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sif (index != -1)\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%sreturn del_%s(index);\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n}\n\n", INDENTATION(--tab_num));
            // 定义一个使用最后一个元素代替被删除元素的删除版本，仅对@pbc_len生效
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_struct_def_, "    bool del_mlast_key_%s(const %s keys);\n", field_desc->name().c_str(),
                       type_name.c_str());
                OUTPUT(ss_cc_, "bool %s::del_mlast_key_%s(const %s keys) {\n", struct_name.c_str(),
                       field_desc->name().c_str(), type_name.c_str());
                OUTPUT(ss_cc_, "%sint32_t index = find_index_%s(keys);\n", INDENTATION(tab_num),
                       field_desc->name().c_str());
                OUTPUT(ss_cc_, "%sif (index != -1)\n", INDENTATION(tab_num));
                OUTPUT(ss_cc_, "%sreturn del_mlast_%s(index);\n", INDENTATION(++tab_num), field_desc->name().c_str());
                OUTPUT(ss_cc_, "%sreturn false;\n}\n\n", INDENTATION(--tab_num));
            }
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_del_batch_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string struct_name = get_type_name(msg_desc->name());
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;
    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        const auto &field_name = field_desc->name();

        // 先获取当前这个变量的类型，如果是 message，需要定义对应的 eq_key 和 eq_ref, 如果是 string, 暂时还不支持
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_DOUBLE ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_FLOAT) {
            continue;  // 不支持repeated string, repeated bytes 还有浮点数互相用==比较不安全，还是不自动生成了吧
        }
        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        std::string type_name = get_field_type_name(field_desc, cmds["@pbc_type"]);
        // 按照下标批量删除，下标必须是从小到大排好序的，且不能重复
        OUTPUT(ss_struct_def_, "%sbool del_batch_%s(const std::vector<uint32_t> &del_idx);\n", INDENTATION(tab_num),
               field_name.c_str());
        OUTPUT(ss_cc_, "bool %s::del_batch_%s(const std::vector<uint32_t> &del_idx) {\n", struct_name.c_str(),
               field_name.c_str());
        // 要看是不是 fix 的，如果是 fix的话，这里是完全不一样的做法
        if (cmds.count("@pbc_fix")) {
            // 先检查一下下标的正确性吧
            OUTPUT(ss_cc_, "%sfor (auto idx : del_idx) {\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%sif (idx >= %s)\n", INDENTATION(++tab_num), get_repeated_limit(field_name).c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            // 将这段内存直接清空
            OUTPUT(ss_cc_, "%sfor (auto idx : del_idx)\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%smemset(&(%s_[idx]), 0, sizeof(%s));\n", INDENTATION(tab_num + 1), field_name.c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "%sreturn true;\n}\n\n", INDENTATION(tab_num));
        } else {
            // 先检查一下下标的正确性吧
            OUTPUT(ss_cc_, "%sif (del_idx.empty())\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));

            OUTPUT(ss_cc_, "%sint pre_idx = -1;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%sfor (auto idx : del_idx) {\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%sif (idx >= %s_num_ || static_cast<int>(idx) <= pre_idx)\n", INDENTATION(++tab_num),
                   field_name.c_str());
            OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%spre_idx = idx;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));

            OUTPUT(ss_cc_, "%suint32_t old_array_size = %s_num_;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_, "%suint32_t read_pos = 0;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%suint32_t write_pos = 0;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%s%s_num_ = 0;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_,
                   "%sfor (auto it = del_idx.begin(); read_pos < old_array_size && read_pos < %s; ++write_pos, "
                   "++read_pos, ++%s_num_) {\n",
                   INDENTATION(tab_num), get_repeated_limit(field_name).c_str(), field_name.c_str());
            OUTPUT(ss_cc_, "%swhile (it != del_idx.end() && read_pos == *it) {\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%s++read_pos;\n", INDENTATION(++tab_num));
            OUTPUT(ss_cc_, "%s++it;\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sif (write_pos == read_pos)\n", INDENTATION(tab_num));
            OUTPUT(ss_cc_, "%scontinue;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%sif (read_pos >= old_array_size || read_pos >= %s)\n", INDENTATION(tab_num),
                   get_repeated_limit(field_name).c_str());
            OUTPUT(ss_cc_, "%sbreak;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%smemmove(&(%s_[write_pos]), &(%s_[read_pos]), sizeof(%s));\n", INDENTATION(tab_num),
                   field_name.c_str(), field_name.c_str(), type_name.c_str());
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn true;\n}\n\n", INDENTATION(tab_num));
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_find_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;
    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        // find
        OUTPUT_DEBUG("    Func: find_%s, now start handle", field_desc->name().c_str());
        // 先获取当前这个变量的类型，如果是 message，需要定义对应的 eq_key 和 eq_ref, 如果是 string, 暂时还不支持
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_DOUBLE ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_FLOAT) {
            continue;  // 不支持 repeated string, repeated bytes 还有浮点数互相用 == 比较不安全，还是不自动生成了吧
        }

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        std::string type_name = get_field_type_name(field_desc, cmds["@pbc_type"]);
        // 看看是不是定长的
        std::string limit_num;
        if (cmds.count("@pbc_fix")) {
            limit_num = get_repeated_limit(field_desc->name().c_str());
        } else {
            limit_num = field_desc->name() + "_num_";
        }
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_MESSAGE) {
            // message 调用自身的 eq_key 函数
            OUTPUT(ss_struct_def_, "\n    template<typename... Keys>\n");
            OUTPUT(ss_struct_def_, "    %s* find_%s(const Keys... keys) {\n", type_name.c_str(),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num),
                   limit_num.c_str());
            OUTPUT(ss_struct_def_, "    %sif (%s_[i].eq_key(keys...))\n", INDENTATION(++tab_num),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sreturn &(%s_[i]);\n", INDENTATION(tab_num + 1), field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_struct_def_, "    %sreturn nullptr;\n    }\n\n", INDENTATION(tab_num));

            // message 调用自身的 eq_ref 函数
            OUTPUT(ss_struct_def_, "    %s* find_%s(const %s& ref);\n", type_name.c_str(), field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "%s* %s::find_%s(const %s& ref) {\n", type_name.c_str(), struct_name.c_str(),
                   field_desc->name().c_str(), type_name.c_str());
            OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num), limit_num.c_str());
            OUTPUT(ss_cc_, "%sif (%s_[i].eq_ref(ref))\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn &(%s_[i]);\n", INDENTATION(tab_num + 1), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn nullptr;\n}\n\n", INDENTATION(tab_num));

            // 顺便生成返回下标的 find 函数
            OUTPUT(ss_struct_def_, "\n    template<typename... Keys>\n");
            OUTPUT(ss_struct_def_, "    int32_t find_index_%s(const Keys... keys) const {\n",
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num),
                   limit_num.c_str());
            OUTPUT(ss_struct_def_, "    %sif (%s_[i].eq_key(keys...))\n", INDENTATION(++tab_num),
                   field_desc->name().c_str());
            OUTPUT(ss_struct_def_, "    %sreturn i;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_struct_def_, "    %s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_struct_def_, "    %sreturn -1;\n    }\n\n", INDENTATION(tab_num));

            // message 调用自身的 eq_ref 函数
            OUTPUT(ss_struct_def_, "    int32_t find_index_%s(const %s &ref) const;\n", field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "int32_t %s::find_index_%s(const %s &ref) const {\n", struct_name.c_str(),
                   field_desc->name().c_str(), type_name.c_str());
            OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num), limit_num.c_str());
            OUTPUT(ss_cc_, "%sif (%s_[i].eq_ref(ref))\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn i;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn -1;\n}\n\n", INDENTATION(tab_num));
        } else {
            OUTPUT(ss_struct_def_, "    %s* find_%s(const %s keys);\n", type_name.c_str(), field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "%s* %s::find_%s(const %s keys) {\n", type_name.c_str(), struct_name.c_str(),
                   field_desc->name().c_str(), type_name.c_str());
            // 普通类型直接用 ==
            OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num), limit_num.c_str());
            OUTPUT(ss_cc_, "%sif (%s_[i] == keys)\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn &(%s_[i]);\n", INDENTATION(tab_num + 1), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn nullptr;\n}\n\n", INDENTATION(tab_num));

            // 顺便生成返回下标的 find 函数
            OUTPUT(ss_struct_def_, "    int32_t find_index_%s(const %s keys) const;\n", field_desc->name().c_str(),
                   type_name.c_str());
            OUTPUT(ss_cc_, "int32_t %s::find_index_%s(const %s keys) const {\n", struct_name.c_str(),
                   field_desc->name().c_str(), type_name.c_str());
            // 普通类型直接用 ==
            OUTPUT(ss_cc_, "%sfor (uint32_t i = 0; i < %s; ++i) {\n", INDENTATION(tab_num), limit_num.c_str());
            OUTPUT(ss_cc_, "%sif (%s_[i] == keys)\n", INDENTATION(++tab_num), field_desc->name().c_str());
            OUTPUT(ss_cc_, "%sreturn i;\n", INDENTATION(tab_num + 1));
            OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));
            OUTPUT(ss_cc_, "%sreturn -1;\n}\n\n", INDENTATION(tab_num));
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_swap_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        const auto &field_name = field_desc->name();

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        // swap
        OUTPUT_DEBUG("    START HANDLE Func: swap_%s", field_name.c_str());

        OUTPUT(ss_struct_def_, "    bool swap_%s(uint32_t idx1, uint32_t idx2);\n", field_name.c_str());
        OUTPUT(ss_cc_, "bool %s::swap_%s(uint32_t idx1, uint32_t idx2) {\n", struct_name.c_str(), field_name.c_str());

        if (!cmds.count("@pbc_fix")) {
            OUTPUT(ss_cc_, "%sif (idx1 >= %s_num_ || idx1 >= %s || idx2 >= %s_num_ || idx2 >= %s)\n",
                   INDENTATION(tab_num), field_name.c_str(), get_repeated_limit(field_name).c_str(), field_name.c_str(),
                   get_repeated_limit(field_name).c_str());
        } else {
            OUTPUT(ss_cc_, "%sif (idx1 >= %s || idx2 >= %s)\n", INDENTATION(tab_num),
                   get_repeated_limit(field_name).c_str(), get_repeated_limit(field_name).c_str());
        }

        OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num + 1));
        OUTPUT(ss_cc_, "%sif (idx1 != idx2) {\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "%sauto tmp = %s_[idx1];\n", INDENTATION(++tab_num), field_name.c_str());
        OUTPUT(ss_cc_, "%s%s_[idx1] = %s_[idx2];\n", INDENTATION(tab_num), field_name.c_str(), field_name.c_str());
        OUTPUT(ss_cc_, "%s%s_[idx2] = tmp;\n", INDENTATION(tab_num), field_name.c_str());
        OUTPUT(ss_cc_, "%s}\n", INDENTATION(--tab_num));

        OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_full_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_fix") || cmds.count("@pbc_vector"), continue);
        OUTPUT_DEBUG("    START HANDLE Func: %s_is_full", field_desc->name().c_str());

        OUTPUT(ss_struct_def_, "    bool %s_is_full() const;\n", field_desc->name().c_str());
        OUTPUT(ss_cc_, "bool %s::%s_is_full() const {\n", struct_name.c_str(), field_desc->name().c_str());

        OUTPUT(ss_cc_, "%sif (%s_num_ >= %s)\n", INDENTATION(tab_num), field_desc->name().c_str(),
               get_repeated_limit(field_desc->name()).c_str());
        OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num + 1));

        OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_repeated_empty_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(!field_desc->is_repeated(), continue);
        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_fix") || cmds.count("@pbc_vector"), continue);

        OUTPUT_DEBUG("    START HANDLE Func: %s_is_empty", field_desc->name().c_str());

        OUTPUT(ss_struct_def_, "    bool %s_is_empty() const;\n", field_desc->name().c_str());
        OUTPUT(ss_cc_, "bool %s::%s_is_empty() const {\n", struct_name.c_str(), field_desc->name().c_str());

        OUTPUT(ss_cc_, "%sif (%s_num_ == 0)\n", INDENTATION(tab_num), field_desc->name().c_str());
        OUTPUT(ss_cc_, "%sreturn true;\n", INDENTATION(tab_num + 1));

        OUTPUT(ss_cc_, "%sreturn false;\n", INDENTATION(tab_num));
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_key_compare_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string struct_name = get_type_name(msg_desc->name());
    std::string ref_str = ss_ref_key_def_.str();
    std::string eq_str = ss_eq_key_def_.str();
    std::string default_result =
        (!ref_str.empty() ? "return true;" : "assert(false);\n" + std::string(INDENTATION(tab_num)) + "return false;");
    OUTPUT(ss_struct_def_, "    bool eq_ref(const %s &ref) const;\n", struct_name.c_str());  // 加入头文件
    OUTPUT(ss_cc_, "bool %s::eq_ref(const %s &ref) const {\n", struct_name.c_str(), struct_name.c_str());
    COND_EXP(!ref_str.empty(), OUTPUT(ss_cc_, "%s", ref_str.c_str()));
    OUTPUT(ss_cc_, "%s%s\n}\n\n", INDENTATION(tab_num), default_result.c_str());

    default_result =
        (!eq_str.empty() ? "return true;" : "assert(false);\n" + std::string(INDENTATION(tab_num)) + "return false;");
    OUTPUT(ss_struct_def_, "    bool eq_key(%s) const;\n", eq_key_args_.c_str());  // 加入头文件
    OUTPUT(ss_cc_, "bool %s::eq_key(%s) const {\n", struct_name.c_str(), eq_key_args_.c_str());
    COND_EXP(!eq_str.empty(), OUTPUT(ss_cc_, "%s", eq_str.c_str()));
    OUTPUT(ss_cc_, "%s%s\n}\n\n", INDENTATION(tab_num), default_result.c_str());
    // 这里要把eq_key_def_stream_ ref_key_def_steam_清空
    // TODO modnarshen use ss_ref_key_def_.clear() ?
    ss_ref_key_def_.str("");
    ss_eq_key_def_.str("");
    eq_key_args_ = "";
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_inc_and_dec_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); ++i) {
        const auto *field_desc = msg_desc->field(i);
        COND_EXP(field_desc->is_repeated(), continue);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);

        auto field_name = field_desc->name();
        auto field_type = get_field_type_name(field_desc, "");

        // size
        OUTPUT_DEBUG("    START HANDLE Func: inc_%s", field_desc->name().c_str());
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_INT32 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_INT64 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_UINT32 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_UINT64) {
            OUTPUT(ss_struct_def_, "    %s inc_%s(%s _inc_value = 1);\n", field_type.c_str(), field_name.c_str(),
                   field_type.c_str());
            OUTPUT(ss_cc_, "%s %s::inc_%s(%s _inc_value) {\n", field_type.c_str(), struct_name.c_str(),
                   field_name.c_str(), field_type.c_str());
            OUTPUT(ss_cc_, "%s%s_ += _inc_value;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_, "}\n\n");
        }

        OUTPUT_DEBUG("    START HANDLE Func: dec_%s", field_desc->name().c_str());
        if (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_INT32 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_INT64 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_UINT32 ||
            field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_UINT64) {
            OUTPUT(ss_struct_def_, "    %s dec_%s(%s _dec_value = 1);\n", field_type.c_str(), field_name.c_str(),
                   field_type.c_str());
            OUTPUT(ss_cc_, "%s %s::dec_%s(%s _dec_value) {\n", field_type.c_str(), struct_name.c_str(),
                   field_name.c_str(), field_type.c_str());
            OUTPUT(ss_cc_, "%s%s_ -= _dec_value;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_, "%sreturn %s_;\n", INDENTATION(tab_num), field_name.c_str());
            OUTPUT(ss_cc_, "}\n\n");
        }
    }

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_clear_member_func(const pb::Descriptor *msg_desc) {
    int tab_num = 1;
    std::string leading_comment, trailing_comment;
    std::map<std::string, std::string> cmds;

    OUTPUT_DEBUG("    START HANDLE Func: Clean");

    std::string struct_name = get_type_name(msg_desc->name());

    for (int i = 0; i < msg_desc->field_count(); i++) {
        const auto *field_desc = msg_desc->field(i);

        pb::SourceLocation loc;
        field_desc->GetSourceLocation(&loc);
        handle_field_comment(loc, cmds, leading_comment, trailing_comment, tab_num);
        COND_EXP(cmds.count("@pbc_vector"), continue);
        bool is_array = (field_desc->is_repeated() || (field_desc->cpp_type() == pb::FieldDescriptor::CPPTYPE_STRING));

        OUTPUT(ss_struct_def_, "    void clear_%s();\n", field_desc->name().c_str());
        OUTPUT(ss_cc_, "void %s::clear_%s() {\n", struct_name.c_str(), field_desc->name().c_str());

        if (is_array) {
            if (!cmds.count("@pbc_fix")) {
                OUTPUT(ss_cc_, "%s%s_num_ = 0;\n", INDENTATION(tab_num), field_desc->name().c_str());
            }
            OUTPUT(ss_cc_, "%smemset(%s_, 0, sizeof(%s_));\n", INDENTATION(tab_num), field_desc->name().c_str(),
                   field_desc->name().c_str());
        } else {
            if (field_desc->cpp_type() != pb::FieldDescriptor::CPPTYPE_MESSAGE) {
                OUTPUT(ss_cc_, "%s%s_ = 0;\n", INDENTATION(tab_num), field_desc->name().c_str());
            } else {
                OUTPUT(ss_cc_, "%smemset(&%s_, 0, sizeof(%s_));\n", INDENTATION(tab_num), field_desc->name().c_str(),
                       field_desc->name().c_str());
            }
        }
        OUTPUT(ss_cc_, "}\n\n");
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_debugstring_func(const pb::Descriptor *msg_desc) {
    OUTPUT_DEBUG("    START HANDLE Func: ShortDebugString");

    uint32_t tab_num = 1;
    const auto &msg_name = msg_desc->name();
    std::string struct_name = get_type_name(msg_desc->name());
    OUTPUT(ss_struct_def_, "    std::string ShortDebugString() const;\n");

    OUTPUT(ss_cc_, "std::string %s::ShortDebugString() const {\n", struct_name.c_str());
    OUTPUT(ss_cc_, "%sstd::string errmsg;\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%s%s::%s pb_msg_obj;\n", INDENTATION(tab_num), message_namespace_.c_str(), msg_name.c_str());
    OUTPUT(ss_cc_, "%sif (!ToPb(&pb_msg_obj, &errmsg))\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%sreturn errmsg;\n", INDENTATION(tab_num + 1));
    OUTPUT(ss_cc_, "%selse\n", INDENTATION(tab_num));
    OUTPUT(ss_cc_, "%sreturn pb_msg_obj.ShortDebugString();\n", INDENTATION(tab_num + 1));
    OUTPUT(ss_cc_, "}\n\n");

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_field_comment(const pb::SourceLocation &loc, std::map<std::string, std::string> &cmds,
                                  std::string &leading_comment, std::string &trailing_comment, int tab_num) const {
    std::string src;
    cmds.clear();
    leading_comment.clear();
    trailing_comment.clear();
    std::map<std::string, std::string> local_cmd;

    if (!loc.leading_comments.empty()) {
        src = loc.leading_comments;
        handle_comment(src, cmds, tab_num);
        if (cmds.find("comment") != cmds.end()) {
            leading_comment = cmds["comment"];
            cmds.erase("comment");
        }
    }
    if (!loc.trailing_comments.empty()) {
        src = loc.trailing_comments;
        local_cmd.clear();
        handle_comment(src, local_cmd, 0);
        if (local_cmd.find("comment") != local_cmd.end()) {
            trailing_comment = local_cmd["comment"];
            local_cmd.erase("comment");
        }
    }

    // 合并两个map
    for (auto iter = local_cmd.begin(); iter != local_cmd.end(); ++iter) {
        auto iter2 = cmds.find(iter->first);
        if (iter2 != cmds.end()) {
            // 合并
            if (iter->first == "@pbc_cpp") {
                iter2->second.append("\n").append(iter->second);
            }
            if (iter->first == "@pbc_len") {
                if (iter->first.empty() || iter2->second.empty())
                    iter2->second.append(iter->second);
            }
            if (iter->first == "@pbc_vector") {
                iter2->second.append("\n").append(iter->second);
            }
        } else {
            cmds.insert(make_pair(iter->first, iter->second));
        }
    }

    for (auto iter3 = cmds.begin(); iter3 != cmds.end(); ++iter3)
        OUTPUT_DEBUG("  CMD: key:{%s} value:{%s}", iter3->first.c_str(), iter3->second.c_str());
    OUTPUT_DEBUG("  CMD: leading_comment: %s", leading_comment.c_str());
    OUTPUT_DEBUG("  CMD: trailing_comment: %s", trailing_comment.c_str());

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_comment(std::string &src, std::map<std::string, std::string> &cmds, int tab_num) const {
    int ret;
    int cnt = pbc::count(src, '\n');
    for (auto iter = cmd_handler_map_.begin(); iter != cmd_handler_map_.end(); ++iter) {
        std::string attachment;
        ret = iter->second(iter->first, src, attachment);
        COND_EXP(ret == 0, cmds.insert({iter->first, attachment}));
    }

    // 有注释
    std::string comment;
    generate_comment(src, comment, tab_num, (cnt == 1));
    COND_EXP(!comment.empty(), cmds.insert({"comment", comment}));

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::generate_comment(const std::string &context, std::string &comment, int tab_num, bool one_line) const {
    comment.clear();
    std::string src = context;

    if (!src.empty()) {
        // 使用双斜杠单行注释或者使用/* */注释但只有两行
        // 形如： /* single line comment..
        //        */
        if (one_line) {
            pbc::trim(src);
            /*
             * 忽略仅仅用双斜杠注释的内容，因为有可能是废弃字段
             * 这里也顺带忽略了上面说的第二种情况，不过那么丑的
             * 的两行注释还是算了吧，改成三行就能幸存。
             */
            COND_RET(src[0] != '/', ErrorCode::PROCESS_SUCCESS);
            // 去掉行头的斜杠
            src.erase(0, src.find_first_not_of("/ "));
            comment += INDENTATION(tab_num);
            comment += ("// " + src);
        } else {
            std::vector<std::string> lines;
            pbc::split(src, "\n", lines);
            if (lines.size() == 1) {
                comment += (std::string(INDENTATION(tab_num)) + "/* " + pbc::trim(lines[0]) + " */");
            } else {
                comment = std::string(INDENTATION(tab_num)) + "/*\n";
                for (size_t i = 0; i < lines.size(); i++) {
                    std::string line = pbc::trim(lines[i]);
                    COND_EXP(line.empty(), continue);
                    comment += (std::string(INDENTATION(tab_num)) + " * " + line + "\n");
                }
                comment += (std::string(INDENTATION(tab_num)) + " */");
            }
        }
    }
    return ErrorCode::PROCESS_SUCCESS;
}
}  // namespace pbc
