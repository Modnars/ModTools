/*
 * @Author: modnarshen
 * @Date: 2022/05/18 17:41:09
 * @LastEditors: modnarshen
 * @Description: 工具主体功能 定义实现
 */
#include <fstream>

#include "pb_const.h"
#include "util/macro.h"
#include "util/string.h"

namespace pbc {

PbConst::~PbConst() {
    if (importer_)
        delete importer_;
}

std::map<std::string, PbConst::CmdHandler> PbConst::cmd_handler_map_ = {
    {"@pbc_declare", PbConst::handle_common_cmd}, {"@pbc_node", PbConst::handle_common_cmd},
    {"@pbc_type", PbConst::handle_common_cmd},    {"@pbc_code", PbConst::handle_common_cmd},
    {"@pbc_len", PbConst::handle_common_cmd},     {"@pbc_fix", PbConst::handle_common_cmd},
    {"@pbc_key", PbConst::handle_common_cmd},     {"@pbc_vector", PbConst::handle_common_cmd},
};

int PbConst::Init(const std::string &proto_filepath, const std::vector<std::string> &proto_file_path,
                  const std::string &out_file_path, const std::string &out_file_name) {
    auto pos = proto_filepath.find_last_of('/');
    if (pos != std::string::npos)
        proto_filename_ = proto_filepath.substr(pos + 1);
    else
        proto_filename_ = proto_filepath;
    OUTPUT_INFO("src:%s|file_name:%s", proto_filepath.c_str(), proto_filename_.c_str());

    if (!out_file_name.empty())
        out_file_name_ = out_file_name;
    else
        out_file_name_ = proto_filename_.substr(0, proto_filename_.find_first_of('.'));

    COND_RET(out_file_name_.empty(), false);
    out_hd_filepath_ = out_file_name_ + out_hd_file_postfix_;
    out_cc_filepath_ = out_file_name_ + out_cc_file_postfix_;
    OUTPUT_INFO("output: %s, %s", out_hd_filepath_.c_str(), out_cc_filepath_.c_str());

    src_tree_.MapPath("", "./");  // 默认加入当前目录
    // 支持 ":" 分隔符
    for (std::size_t i = 0; i < proto_file_path.size(); ++i) {
        std::string curr_proto_path = proto_file_path[i];
        while (true) {
            auto pos = curr_proto_path.find(":");
            if (pos == std::string::npos) {
                src_tree_.MapPath("", curr_proto_path);
                proto_paths_.emplace_back(curr_proto_path);
                OUTPUT_DEBUG("proto path: %s", curr_proto_path.c_str());
                break;
            } else {
                src_tree_.MapPath("", curr_proto_path.substr(0, pos));
                proto_paths_.emplace_back(curr_proto_path.substr(0, pos));
                OUTPUT_DEBUG("proto path: %s", curr_proto_path.substr(0, pos).c_str());
                curr_proto_path = curr_proto_path.substr(pos + 1);
            }
        }
    }

    importer_ = new pb::compiler::Importer(&src_tree_, &error_collector_);
    COND_RET_ELOG(!importer_, ErrorCode::PROCESS_FAILURE, "init importer failed");

    file_desc_ = importer_->Import(proto_filename_);
    COND_EXP_ELOG(!file_desc_, error_collector_.PrintError();
                  return ErrorCode::PROCESS_FAILURE, "cannot open proto file|file:%s", proto_filename_.c_str());

    out_hd_filepath_ = out_file_path_ + "/" + out_file_name_ + out_hd_file_postfix_;
    out_cc_filepath_ = out_file_path_ + "/" + out_file_name_ + out_cc_file_postfix_;

    auto ret = CheckOnInit();
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::Parse() {
    int ret = ErrorCode::PROCESS_SUCCESS;

    // check declare
    std::string declare_code_block;
    COND_RET_ILOG(!CheckFileAndGetDeclarationCode(file_desc_, declare_code_block), ErrorCode::PROCESS_SUCCESS,
                  "skip no declaring file|file:%s", proto_filename_.c_str());

    // context
    std::stringstream context;
    OUTPUT(context,
           "/*\n"
           " * This file is generated by `pbc`. Source proto file: %s\n"
           " * DO NOT CHANGE IT DIRECTLY, CHANGE SOURCE PROTO FILE INSTEADLY.\n"
           " */\n\n",
           proto_filename_.c_str());

    ss_hd_ << context.str();
    ss_cc_ << context.str();

    // #pragma
    OUTPUT(ss_hd_, "#pragma once\n\n");
    // #include
    OUTPUT(ss_hd_, "#include \"%s.pb.h\"\n",
           proto_filename_.substr(0, proto_filename_.size() - PB_POSTFIX_LEN).c_str());

    // process dependency
    ret = for_each_dependency(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    OUTPUT(ss_hd_, "\n");
    OUTPUT(ss_cc_, "#include \"%s%s\"\n\n", out_file_name_.c_str(), out_hd_file_postfix_.c_str());

    COND_EXP(!declare_code_block.empty(), OUTPUT(ss_hd_, "%s\n", declare_code_block.c_str()));
    OUTPUT(ss_hd_, "\n");

    // process namespace
    ret = handle_package(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);
    OUTPUT(ss_hd_, "\n");
    OUTPUT(ss_cc_, "\n");

    // process enum
    ret = for_each_enum(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);
    OUTPUT(ss_hd_, "\n");

    ret = for_each_message(file_desc_);
    COND_RET(ret != ErrorCode::PROCESS_SUCCESS, ret);

    // 将 @pbc_code 生成的代码写入头文件
    COND_EXP(!ss_pbc_code_.str().empty(), ss_hd_ << ss_pbc_code_.str() << std::endl);

    // 将前置类型声明写入头文件
    COND_EXP(!ss_declaration_.str().empty(), ss_hd_ << ss_declaration_.str() << std::endl);

    // 将文件级别 enum 写入头文件
    COND_EXP(!ss_enum_.str().empty(), ss_hd_ << ss_enum_.str() << std::endl);

    // 将结构体声明写入头文件
    COND_EXP(!ss_struct_decl_.str().empty(), ss_hd_ << ss_struct_decl_.str() << std::endl);

    // namespace 结束
    for (std::size_t i = 0; i < namespace_num_; ++i) {
        OUTPUT(ss_hd_, "}  // namespace");
        OUTPUT(ss_cc_, "}  // namespace");
    }

    return ret;
}

int PbConst::handle_dependency(const pb::FileDescriptor *file_desc, const pb::FileDescriptor *dep_desc) {
    std::string code_block;
    COND_RET(!CheckFileAndGetDeclarationCode(dep_desc, code_block), ErrorCode::PROCESS_SUCCESS);

    std::string dep_name = dep_desc->name();
    if ((dep_name.size() > PB_POSTFIX_LEN) && (dep_name.substr(dep_name.size() - PB_POSTFIX_LEN) == ".proto")) {
        dep_name.resize(dep_name.size() - PB_POSTFIX_LEN);
        OUTPUT(ss_hd_, "#include \"%s%s\"\n", dep_name.c_str(), out_hd_file_postfix_.c_str());
    } else {
        OUTPUT_ERROR("proto filename postfix should be .proto|file:%s\n", dep_name.c_str());
        return ErrorCode::PROCESS_FAILURE;
    }

    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_package(const pb::FileDescriptor *file_desc) {
    std::string pkg_string = file_desc->package();
    while (pkg_string.size()) {
        std::string add_ns;
        auto pos = pkg_string.find('.');
        if (pos == std::string::npos) {
            add_ns = pkg_string;
            pkg_string.clear();
        } else {
            add_ns = pkg_string.substr(0, pos);
            pkg_string = pkg_string.substr(pos + 1);
        }
        push_namespace(message_namespace_, add_ns);

        COND_EXP(pkg_string.empty(), add_ns = "pbc");
        push_namespace(pbc_namespace_, add_ns);

        OUTPUT(ss_hd_, "namespace %s {\n", add_ns.c_str());
        OUTPUT(ss_cc_, "namespace %s {\n", add_ns.c_str());
        ++namespace_num_;
    }
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_enum(const pb::FileDescriptor *file_desc, const pb::EnumDescriptor *enum_desc) {
    return ErrorCode::PROCESS_SUCCESS;
}

int PbConst::handle_enum(const pb::Descriptor *msg_desc, const pb::EnumDescriptor *enum_desc) {
    return 0;
}

int PbConst::handle_message(const pb::FileDescriptor *file_desc, const pb::Descriptor *msg_desc) {
    return 0;
}

int PbConst::handle_nested(const pb::Descriptor *msg_desc, const pb::Descriptor *nested_desc) {
    OUTPUT_STDERR("Sorry, pbc does not support nested message currently, please shift it out to continue.");
    OUTPUT_ERROR("message:%s|nested:%s", msg_desc->name().c_str(), nested_desc->name().c_str());
    return ErrorCode::PROCESS_FAILURE;
}

int PbConst::CheckOnInit() const {
    for (std::size_t i = 0; i < type_vector.size(); ++i)
        COND_RET_ELOG(type_vector[i].pb_cxx_type != static_cast<int>(i), ErrorCode::PROCESS_FAILURE,
                      "type vector pb_cxx_type wrong|pb_cxx_type:%d|index:%zu", type_vector[i].pb_cxx_type, i);
    return ErrorCode::PROCESS_SUCCESS;
}

bool PbConst::CheckFileAndGetDeclarationCode(const pb::FileDescriptor *file_desc, std::string &code_block) const {
    int ret = ErrorCode::PROCESS_SUCCESS;
    pb::FileDescriptorProto file_proto;
    file_desc->CopySourceCodeInfoTo(&file_proto);
    const pb::SourceCodeInfo *src_info = &file_proto.source_code_info();

    for (int i = 0; i < src_info->location_size(); ++i) {
        const auto *loc = &src_info->location(i);
        if ((loc->path_size() == 1 && loc->path(0) == 2) ||  // import
            (loc->path_size() == 2 && loc->path(0) == 3)) {  // package
            if (!loc->leading_comments().empty()) {
                std::string src = loc->leading_comments();
                std::string attachment;
                ret = handle_common_cmd("@pbc_declare", src, attachment);
                COND_EXP(ret == ErrorCode::PROCESS_SUCCESS, std::swap(code_block, src); return true);
            }
        }
    }
    return false;
}

int PbConst::handle_common_cmd(const std::string &cmd, std::string &src, std::string &attachment) {
    int ret = ErrorCode::PROCESS_SUCCESS;
    bool found = false;
    std::size_t pos;
    std::string line, new_src;
    attachment.clear();
    std::vector<std::string> src_lines;
    split(src, "\n", src_lines);

    for (std::size_t i = 0; i < src_lines.size(); ++i) {
        line.assign(trim(src_lines[i]));
        COND_EXP(line.empty(), continue);
        pos = line.find(cmd);
        if (pos != std::string::npos) {
            found = true;
            std::string temp = line.substr(pos + cmd.size());
            trim(temp);
            COND_EXP(temp.empty(), continue);
            attachment += (attachment.empty() ? temp : "\n" + temp);
        } else {
            new_src += (new_src.empty() ? line : "\n" + line);
        }
    }
    std::swap(src, new_src);  // 将 src 赋值为 new_src
    return found ? ErrorCode::PROCESS_SUCCESS : ErrorCode::PROCESS_FAILURE;
}

void PbConst::push_namespace(std::string &ns, const std::string &add_ns) {
    ns += (ns.empty() ? add_ns : "::" + add_ns);
}

std::string PbConst::get_type_name(const std::string &proto_type_name) const {
    return "M" + proto_type_name;
}

std::string PbConst::get_field_type_name(const pb::FieldDescriptor *field_desc, const std::string &custom_type) const {
    switch (field_desc->cpp_type()) {
        case pb::FieldDescriptor::CPPTYPE_MESSAGE: {
            return get_type_name(field_desc->message_type()->name());
        }
        case pb::FieldDescriptor::CPPTYPE_INT32:
        case pb::FieldDescriptor::CPPTYPE_INT64:
        case pb::FieldDescriptor::CPPTYPE_UINT32:
        case pb::FieldDescriptor::CPPTYPE_UINT64: {
            if (custom_type.empty())
                return type_vector[field_desc->cpp_type()].cxx_type;
            else
                return custom_type;
        }
        case pb::FieldDescriptor::CPPTYPE_DOUBLE:
        case pb::FieldDescriptor::CPPTYPE_FLOAT:
        case pb::FieldDescriptor::CPPTYPE_BOOL:
        case pb::FieldDescriptor::CPPTYPE_STRING: {
            return type_vector[field_desc->cpp_type()].cxx_type;
        }
        default: {
            OUTPUT_ERROR("bad protobuf cxx type|pb_cxx_type:%u", field_desc->cpp_type());
            break;
        }
    }
    return "";
}

int PbConst::write_file(std::stringstream &ss, const std::string &filepath) const {
    COND_RET(ss.str().empty(), ErrorCode::PROCESS_SUCCESS);
    ::remove(filepath.c_str());
    std::ofstream ofs;
    ofs.open(filepath.c_str(), std::ios::out | std::ios::trunc);
    COND_RET_ELOG(ofs.fail(), ErrorCode::PROCESS_FAILURE, "open out filepath failed|out_path:%s", filepath.c_str());
    ofs << ss.str();
    ofs.close();
    return ErrorCode::PROCESS_SUCCESS;
}
}  // namespace pbc
